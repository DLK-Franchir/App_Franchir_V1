generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum UserRole {
  PATIENT
  SURGEON
  STAFF
}

enum DocumentType {
  MEDICAL_REPORT
  IMAGING
  PRESCRIPTION
  INSURANCE
  IDENTIFICATION
  OTHER
}

enum NotificationType {
  MESSAGE
  DOCUMENT_UPLOADED
  APPOINTMENT_REMINDER
  SYSTEM
  MEDICAL_UPDATE
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

enum Language {
  FRENCH
  ENGLISH
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String?
  firstName     String?
  lastName      String?
  role          UserRole  @default(PATIENT)
  phone         String?
  language      Language  @default(FRENCH)
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?

  // Relations
  accounts              Account[]
  sessions              Session[]
  medicalProfile        MedicalProfile?
  documents             Document[]
  patientDocuments      Document[]           @relation("PatientDocuments")
  patientMedicalProfile MedicalProfile[]     @relation("PatientSurgeon")
  sentMessages          Message[]            @relation("SentMessages")
  receivedMessages      Message[]            @relation("ReceivedMessages")
  conversations         ConversationUser[]
  notifications         Notification[]

  @@map("users")
}

model MedicalProfile {
  id                    String   @id @default(cuid())
  userId                String   @unique
  dateOfBirth           DateTime?
  gender                String?
  bloodType             String?
  allergies             String?
  currentMedications    String?
  medicalHistory        String?
  emergencyContactName  String?
  emergencyContactPhone String?
  insuranceProvider     String?
  insuranceNumber       String?
  diagnosisDetails      String?
  surgeryType           String?
  surgeryDate           DateTime?
  surgeonId             String?
  hospitalName          String?
  notes                 String?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  surgeon User? @relation("PatientSurgeon", fields: [surgeonId], references: [id])

  @@map("medical_profiles")
}

model Document {
  id             String       @id @default(cuid())
  title          String
  description    String?
  fileName       String
  fileSize       Int
  mimeType       String
  filePath       String
  type           DocumentType @default(OTHER)
  isConfidential Boolean      @default(true)
  uploadedById   String
  patientId      String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  uploadedBy User  @relation(fields: [uploadedById], references: [id])
  patient    User? @relation("PatientDocuments", fields: [patientId], references: [id])

  @@map("documents")
}

model Conversation {
  id          String   @id @default(cuid())
  title       String?
  isGroup     Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  participants ConversationUser[]
  messages     Message[]

  @@map("conversations")
}

model ConversationUser {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  joinedAt       DateTime @default(now())
  lastReadAt     DateTime?

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@map("conversation_users")
}

model Message {
  id              String        @id @default(cuid())
  content         String
  conversationId  String
  senderId        String
  recipientId     String?
  status          MessageStatus @default(SENT)
  isSystemMessage Boolean       @default(false)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id])
  recipient    User?        @relation("ReceivedMessages", fields: [recipientId], references: [id])

  @@map("messages")
}

model Notification {
  id        String           @id @default(cuid())
  title     String
  message   String
  type      NotificationType @default(SYSTEM)
  isRead    Boolean          @default(false)
  userId    String
  link      String?
  createdAt DateTime         @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
